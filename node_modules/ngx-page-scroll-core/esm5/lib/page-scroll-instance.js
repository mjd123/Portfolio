/**
 * Represents a scrolling action
 */
var PageScrollInstance = /** @class */ (function () {
    /**
     * Private constructor, requires the properties assumed to be the bare minimum.
     * Use the factory methods to create instances:
     *      {@link PageScrollService#create}
     */
    function PageScrollInstance(pageScrollOptions) {
        /**
         * These properties will be set/manipulated if the scroll animation starts
         */
        /* The initial value of the scrollTop or scrollLeft position when the animation starts */
        this.startScrollPosition = 0;
        /* Whether an interrupt listener is attached to the body or not */
        this.interruptListenersAttached = false;
        /* References to the timer instance that is used to perform the scroll animation to be
         able to clear it on animation end*/
        this.timer = null;
        if (!pageScrollOptions.scrollViews || pageScrollOptions.scrollViews.length === 0) {
            pageScrollOptions.scrollViews = [
                pageScrollOptions.document.documentElement,
                pageScrollOptions.document.body,
                pageScrollOptions.document.body.parentNode,
            ];
            this.isInlineScrolling = false;
        }
        else {
            this.isInlineScrolling = true;
        }
        this.pageScrollOptions = pageScrollOptions;
    }
    PageScrollInstance.getScrollingTargetPosition = function (pageScrollOptions, scrollTargetElement) {
        var body = pageScrollOptions.document.body;
        var docEl = pageScrollOptions.document.documentElement;
        var windowPageYOffset = pageScrollOptions.document.defaultView &&
            pageScrollOptions.document.defaultView.pageYOffset || undefined;
        var windowPageXOffset = pageScrollOptions.document.defaultView &&
            pageScrollOptions.document.defaultView.pageXOffset || undefined;
        var scrollTop = windowPageYOffset || docEl.scrollTop || body.scrollTop;
        var scrollLeft = windowPageXOffset || docEl.scrollLeft || body.scrollLeft;
        var clientTop = docEl.clientTop || body.clientTop || 0;
        var clientLeft = docEl.clientLeft || body.clientLeft || 0;
        if (scrollTargetElement === undefined || scrollTargetElement === null) {
            // No element found, so return the current position to not cause any change in scroll position
            return { top: scrollTop, left: scrollLeft };
        }
        var box = scrollTargetElement.getBoundingClientRect();
        var top = box.top + scrollTop - clientTop;
        var left = box.left + scrollLeft - clientLeft;
        return { top: Math.round(top), left: Math.round(left) };
    };
    PageScrollInstance.getInlineScrollingTargetPosition = function (pageScrollOptions, scrollTargetElement) {
        var position = { top: scrollTargetElement.offsetTop, left: scrollTargetElement.offsetLeft };
        if (pageScrollOptions.advancedInlineOffsetCalculation && pageScrollOptions.scrollViews.length === 1) {
            var accumulatedParentsPos = { top: 0, left: 0 };
            // not named window to make sure we're not getting the global window variable by accident
            var theWindow = scrollTargetElement.ownerDocument.defaultView;
            var parentFound = false;
            // Start parent is the immediate parent
            var parent_1 = scrollTargetElement.parentElement;
            // Iterate upwards all parents
            while (!parentFound && parent_1 !== undefined && parent_1 !== null) {
                if (theWindow.getComputedStyle(parent_1).getPropertyValue('position') === 'relative') {
                    accumulatedParentsPos.top += parent_1.offsetTop;
                    accumulatedParentsPos.left += parent_1.offsetLeft;
                }
                // Next iteration
                parent_1 = parent_1.parentElement;
                parentFound = parent_1 === pageScrollOptions.scrollViews[0];
            }
            if (parentFound) {
                // Only use the results if we found the parent, otherwise we accumulated too much anyway
                position.top += accumulatedParentsPos.top;
                position.left += accumulatedParentsPos.left;
            }
            else {
                /* TODO Uncomment
                if (PageScrollConfig._logLevel >= 2 || (PageScrollConfig._logLevel >= 1 && isDevMode())) {
                  console.warn('Unable to find nested scrolling targets parent!');
                }*/
            }
        }
        return position;
    };
    PageScrollInstance.prototype.getScrollPropertyValue = function (scrollingView) {
        if (!this.pageScrollOptions.verticalScrolling) {
            return scrollingView.scrollLeft;
        }
        return scrollingView.scrollTop;
    };
    PageScrollInstance.prototype.getScrollClientPropertyValue = function (scrollingView) {
        if (!this.pageScrollOptions.verticalScrolling) {
            return scrollingView.clientWidth;
        }
        return scrollingView.clientHeight;
    };
    /**
     * Extract the exact location of the scrollTarget element.
     *
     * Extract the scrollTarget HTMLElement from the given PageScrollTarget object. The latter one may be
     * a string like "#heading2", then this method returns the corresponding DOM element for that id.
     *
     */
    PageScrollInstance.prototype.extractScrollTargetPosition = function () {
        var scrollTargetElement = this.getScrollTargetElement();
        if (scrollTargetElement === null || scrollTargetElement === undefined) {
            // Scroll target not found
            return { top: NaN, left: NaN };
        }
        if (this.isInlineScrolling) {
            return PageScrollInstance.getInlineScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);
        }
        return PageScrollInstance.getScrollingTargetPosition(this.pageScrollOptions, scrollTargetElement);
    };
    /**
     * Get the top offset of the scroll animation.
     * This automatically takes the offset location of the scrolling container/scrolling view
     * into account (for nested/inline scrolling).
     */
    PageScrollInstance.prototype.getCurrentOffset = function () {
        return this.pageScrollOptions.scrollOffset;
    };
    /**
     * Sets the "scrollTop" or "scrollLeft" property for all scrollViews to the provided value
     * @return true if at least for one ScrollTopSource the scrollTop/scrollLeft value could be set and it kept the new value.
     *          false if it failed for all ScrollViews, meaning that we should stop the animation
     *          (probably because we're at the end of the scrolling region)
     */
    PageScrollInstance.prototype.setScrollPosition = function (position) {
        var _this = this;
        // Set the new scrollTop/scrollLeft to all scrollViews elements
        return this.pageScrollOptions.scrollViews.reduce(function (oneAlreadyWorked, scrollingView) {
            var startScrollPropertyValue = _this.getScrollPropertyValue(scrollingView);
            if (scrollingView && startScrollPropertyValue !== undefined && startScrollPropertyValue !== null) {
                var scrollDistance = Math.abs(startScrollPropertyValue - position);
                // The movement we need to perform is less than 2px
                // This we consider a small movement which some browser may not perform when
                // changing the scrollTop/scrollLeft property
                // Thus in this cases we do not stop the scroll animation, although setting the
                // scrollTop/scrollLeft value "fails"
                var isSmallMovement = scrollDistance < _this.pageScrollOptions._minScrollDistance;
                if (!_this.pageScrollOptions.verticalScrolling) {
                    scrollingView.scrollLeft = position;
                }
                else {
                    scrollingView.scrollTop = position;
                }
                // Return true if setting the new scrollTop/scrollLeft value worked
                // We consider that it worked if the new scrollTop/scrollLeft value is closer to the
                // desired scrollTop/scrollLeft than before (it might not be exactly the value we
                // set due to dpi or rounding irregularities)
                if (isSmallMovement || scrollDistance > Math.abs(_this.getScrollPropertyValue(scrollingView) - position)) {
                    return true;
                }
            }
            return oneAlreadyWorked;
        }, false);
    };
    /**
     * Trigger firing a animation finish event
     * @param value Whether the animation finished at the target (true) or got interrupted (false)
     */
    PageScrollInstance.prototype.fireEvent = function (value) {
        if (this.pageScrollOptions.scrollFinishListener) {
            this.pageScrollOptions.scrollFinishListener.emit(value);
        }
    };
    /**
     * Attach the interrupt listeners to the PageScrollInstance body. The given interruptReporter
     * will be called if any of the attached events is fired.
     *
     * Possibly attached interruptListeners are automatically removed from the body before the new one will be attached.
     */
    PageScrollInstance.prototype.attachInterruptListeners = function (interruptReporter) {
        var _this = this;
        if (this.interruptListenersAttached) {
            // Detach possibly existing listeners first
            this.detachInterruptListeners();
        }
        this.interruptListener = function (event) {
            interruptReporter.report(event, _this);
        };
        this.pageScrollOptions.interruptEvents.forEach(function (event) { return _this.pageScrollOptions.document.body.addEventListener(event, _this.interruptListener); });
        this.interruptListenersAttached = true;
    };
    /**
     * Remove event listeners from the body and stop listening for events that might be treated as "animation
     * interrupt" events.
     */
    PageScrollInstance.prototype.detachInterruptListeners = function () {
        var _this = this;
        this.pageScrollOptions.interruptEvents.forEach(function (event) { return _this.pageScrollOptions.document.body.removeEventListener(event, _this.interruptListener); });
        this.interruptListenersAttached = false;
    };
    PageScrollInstance.prototype.getScrollTargetElement = function () {
        if (typeof this.pageScrollOptions.scrollTarget === 'string') {
            var targetSelector = this.pageScrollOptions.scrollTarget;
            if (targetSelector.match(/^#[^\s]+$/g) !== null) {
                // It's an id selector and a valid id, as it does not contain any white space characters
                return this.pageScrollOptions.document.getElementById(targetSelector.substr(1));
            }
            return this.pageScrollOptions.document.querySelector(targetSelector);
        }
        return this.pageScrollOptions.scrollTarget;
    };
    return PageScrollInstance;
}());
export { PageScrollInstance };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFnZS1zY3JvbGwtaW5zdGFuY2UuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtcGFnZS1zY3JvbGwtY29yZS8iLCJzb3VyY2VzIjpbImxpYi9wYWdlLXNjcm9sbC1pbnN0YW5jZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFtREE7O0dBRUc7QUFDSDtJQWdDRTs7OztPQUlHO0lBQ0gsNEJBQVksaUJBQW9DO1FBM0JoRDs7V0FFRztRQUNILHlGQUF5RjtRQUNsRix3QkFBbUIsR0FBRyxDQUFDLENBQUM7UUFXL0Isa0VBQWtFO1FBQzNELCtCQUEwQixHQUFHLEtBQUssQ0FBQztRQUUxQzs0Q0FDb0M7UUFDN0IsVUFBSyxHQUFRLElBQUksQ0FBQztRQVF2QixJQUFJLENBQUMsaUJBQWlCLENBQUMsV0FBVyxJQUFJLGlCQUFpQixDQUFDLFdBQVcsQ0FBQyxNQUFNLEtBQUssQ0FBQyxFQUFFO1lBQ2hGLGlCQUFpQixDQUFDLFdBQVcsR0FBRztnQkFDOUIsaUJBQWlCLENBQUMsUUFBUSxDQUFDLGVBQWU7Z0JBQzFDLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxJQUFJO2dCQUMvQixpQkFBaUIsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFVBQVU7YUFDM0MsQ0FBQztZQUNGLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxLQUFLLENBQUM7U0FDaEM7YUFBTTtZQUNMLElBQUksQ0FBQyxpQkFBaUIsR0FBRyxJQUFJLENBQUM7U0FDL0I7UUFFRCxJQUFJLENBQUMsaUJBQWlCLEdBQUcsaUJBQWlCLENBQUM7SUFDN0MsQ0FBQztJQUVjLDZDQUEwQixHQUF6QyxVQUEwQyxpQkFBb0MsRUFDcEMsbUJBQWdDO1FBQ3hFLElBQU0sSUFBSSxHQUFHLGlCQUFpQixDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUM7UUFDN0MsSUFBTSxLQUFLLEdBQUcsaUJBQWlCLENBQUMsUUFBUSxDQUFDLGVBQWUsQ0FBQztRQUV6RCxJQUFNLGlCQUFpQixHQUFXLGlCQUFpQixDQUFDLFFBQVEsQ0FB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SUFDMUMsQ0FBQztJQUVPLG1EQUFzQixHQUE5QjtRQUNFLElBQUksT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxLQUFLLFFBQVEsRUFBRTtZQUMzRCxJQUFNLGNBQWMsR0FBVyxJQUFJLENBQUMsaUJBQWlCLENBQUMsWUFBWSxDQUFDO1lBQ25FLElBQUksY0FBYyxDQUFDLEtBQUssQ0FBQyxZQUFZLENBQUMsS0FBSyxJQUFJLEVBQUU7Z0JBQy9DLHdGQUF3RjtnQkFFeEYsT0FBTyxJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLGNBQWMsQ0FBQyxjQUFjLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7YUFDakY7WUFFRCxPQUFvQixJQUFJLENBQUMsaUJBQWlCLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQyxjQUFjLENBQUMsQ0FBQztTQUNuRjtRQUVELE9BQW9CLElBQUksQ0FBQyxpQkFBaUIsQ0FBQyxZQUFZLENBQUM7SUFDMUQsQ0FBQztJQUNILHlCQUFDO0FBQUQsQ0FBQyxBQWxRRCxJQWtRQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEV2ZW50RW1pdHRlciB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xuaW1wb3J0IHsgUGFnZVNjcm9sbENvbmZpZyB9IGZyb20gJy4vdHlwZXMvcGFnZS1zY3JvbGwuY29uZmlnJztcbmltcG9ydCB7IFBhZ2VTY3JvbGxUYXJnZXQgfSBmcm9tICcuL3R5cGVzL3BhZ2Utc2Nyb2xsLXRhcmdldCc7XG5pbXBvcnQgeyBQYWdlU2Nyb2xsVmlld3MgfSBmcm9tICcuL3R5cGVzL3BhZ2Utc2Nyb2xsLXZpZXcnO1xuaW1wb3J0IHsgRWFzaW5nTG9naWMgfSBmcm9tICcuL3R5cGVzL2Vhc2luZy1sb2dpYyc7XG5cbi8qKlxuICogQW4gSW50ZXJmYWNlIHNwZWNpZnlpbmcgdGhlIHBvc3NpYmxlIG9wdGlvbnMgdG8gYmUgcGFzc2VkIGludG8gdGhlIG5ld0luc3RhbmNlKCkgZmFjdG9yeSBtZXRob2RcbiAqL1xuZXhwb3J0IGludGVyZmFjZSBQYWdlU2Nyb2xsT3B0aW9ucyBleHRlbmRzIFBhZ2VTY3JvbGxDb25maWcge1xuICAvKipcbiAgICogVGhlIGRvY3VtZW50IG9iamVjdCBvZiB0aGUgY3VycmVudCBhcHBcbiAgICovXG4gIGRvY3VtZW50OiBEb2N1bWVudDtcblxuICAvKipcbiAgICogQSBzcGVjaWZpY2F0aW9uIG9mIHRoZSBET00gZWxlbWVudCB0byBzY3JvbGwgdG8uIEVpdGhlciBhIHN0cmluZyByZWZlcnJpbmcgdG8gYW5cbiAgICogZWxlbWVudCB1c2luZyBhIHZhbGlkIGNzcyBzZWxlY3RvciAoYCN0YXJnZXRgLCBgLmNsYXNzYCwgYGRpdi5jbGFzc2ApIG9yIGEgSFRNTEVsZW1lbnRcbiAgICogdGhhdCBpcyBhdHRhY2hlZCB0byB0aGUgZG9jdW1lbnQncyBET00gdHJlZS5cbiAgICovXG4gIHNjcm9sbFRhcmdldDogUGFnZVNjcm9sbFRhcmdldDtcblxuICAvKipcbiAgICogQXJyYXkgb2YgSFRNTEVsZW1lbnRzIG9yIHRoZSBib2R5IG9iamVjdCB0aGF0IHNob3VsZCBiZSBtYW5pcHVsYXRlZCB3aGlsZSBwZXJmb3JtaW5nXG4gICAqIHRoZSBzY3JvbGwgYW5pbWF0aW9uLlxuICAgKi9cbiAgc2Nyb2xsVmlld3M/OiBQYWdlU2Nyb2xsVmlld3NbXTtcblxuICAvKipcbiAgICogTWF4aW11bSBzcGVlZCB0byBiZSB1c2VkIGZvciB0aGUgc2Nyb2xsIGFuaW1hdGlvbi4gT25seSB0YWtlblxuICAgKiBpbnRvIGFjY291bnQgb2Ygbm8gZHVyYXRpb24gaXMgcHJvdmlkZWRcbiAgICovXG4gIHNwZWVkPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBIGxpc3RlbmVyIHRvIGJlIGNhbGxlZCB3aGVuZXZlciB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBzdG9wc1xuICAgKi9cbiAgc2Nyb2xsRmluaXNoTGlzdGVuZXI/OiBFdmVudEVtaXR0ZXI8Ym9vbGVhbj47XG5cbiAgbmFtZXNwYWNlPzogc3RyaW5nO1xuICB2ZXJ0aWNhbFNjcm9sbGluZz86IGJvb2xlYW47XG4gIGR1cmF0aW9uPzogbnVtYmVyO1xuICBzY3JvbGxPZmZzZXQ/OiBudW1iZXI7XG4gIGFkdmFuY2VkSW5saW5lT2Zmc2V0Q2FsY3VsYXRpb24/OiBib29sZWFuO1xuICBpbnRlcnJ1cHRFdmVudHM/OiBzdHJpbmdbXTtcbiAgaW50ZXJydXB0S2V5cz86IHN0cmluZ1tdO1xuICBpbnRlcnJ1cHRpYmxlPzogYm9vbGVhbjtcbiAgc2Nyb2xsSW5WaWV3PzogYm9vbGVhbjtcbiAgZWFzaW5nTG9naWM/OiBFYXNpbmdMb2dpYztcbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgc2Nyb2xsaW5nIGFjdGlvblxuICovXG5leHBvcnQgY2xhc3MgUGFnZVNjcm9sbEluc3RhbmNlIHtcblxuICBwdWJsaWMgcGFnZVNjcm9sbE9wdGlvbnM6IFBhZ2VTY3JvbGxPcHRpb25zO1xuXG4gIHByaXZhdGUgaXNJbmxpbmVTY3JvbGxpbmc6IGJvb2xlYW47XG5cbiAgLyogVGhlIGxpc3RlbmVyIHRoYXQgdGhpcyBzY3JvbGwgaW5zdGFuY2UgYXR0YWNoZXMgdG8gdGhlIGJvZHkgdG8gbGlzdGVuIGZvciBpbnRlcnJ1cHQgZXZlbnRzXG4gIFdlJ3JlIGtlZXBpbmcgYSByZWZlcmVuY2UgdG8gaXQgc28gd2UgY2FuIHByb3Blcmx5IHJlbW92ZSBpdCB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMgKi9cbiAgcHJpdmF0ZSBpbnRlcnJ1cHRMaXN0ZW5lcjogRXZlbnRMaXN0ZW5lck9yRXZlbnRMaXN0ZW5lck9iamVjdDtcblxuICAvKipcbiAgICogVGhlc2UgcHJvcGVydGllcyB3aWxsIGJlIHNldC9tYW5pcHVsYXRlZCBpZiB0aGUgc2Nyb2xsIGFuaW1hdGlvbiBzdGFydHNcbiAgICovXG4gIC8qIFRoZSBpbml0aWFsIHZhbHVlIG9mIHRoZSBzY3JvbGxUb3Agb3Igc2Nyb2xsTGVmdCBwb3NpdGlvbiB3aGVuIHRoZSBhbmltYXRpb24gc3RhcnRzICovXG4gIHB1YmxpYyBzdGFydFNjcm9sbFBvc2l0aW9uID0gMDtcbiAgLyogVGhlIHRhcmdldCB2YWx1ZSBvZiB0aGUgc2Nyb2xsVG9wIG9yIHNjcm9sbExlZnQgcG9zaXRpb24gZm9yIHRoZSBhbmltYXRpb24gKGFrYSBcInRoZSBmaW5hbCBkZXN0aW5hdGlvblwiKSAqL1xuICBwdWJsaWMgdGFyZ2V0U2Nyb2xsUG9zaXRpb246IG51bWJlcjtcbiAgLyogRGlmZmVyZW5jZSBiZXR3ZWVuIHN0YXJ0U2Nyb2xsUG9zaXRpb24gYW5kIHRhcmdldFNjcm9sbFBvc2l0aW9uLiBQcmUtY2FsY3VsYXRlZCB0byBtaW5pbWl6ZSBjb21wdXRhdGlvbnMgZHVyaW5nIGFuaW1hdGlvbiAqL1xuICBwdWJsaWMgZGlzdGFuY2VUb1Njcm9sbDogbnVtYmVyO1xuICAvKiBUaGUgdGltZXN0YW1wIHdoZW4gdGhlIGFuaW1hdGlvbiBzdGFydHMvZ290IHN0YXJ0ZWQgKi9cbiAgcHVibGljIHN0YXJ0VGltZTogbnVtYmVyO1xuICAvKiBUaGUgZXN0aW1hdGUgZW5kIHRpbWUgb2YgdGhlIGFuaW1hdGlvbiwgY2FsY3VsYXRlZCBieSBzdGFydFRpbWUgKyBkdXJhdGlvbiAqL1xuICBwdWJsaWMgZW5kVGltZTogbnVtYmVyO1xuICAvKiBUaGUgZHVyYXRpb24gYSBzdGFydGVkIGFuaW1hdGlvbiB0YWtlcy4gVGhpcyBtYXkgbWF0Y2ggdGhlIF9kdXJhdGlvbiBvciBiZSBhZGp1c3RlZCBkdWUgdG8gdGhlIF9zcGVlZCBvcHRpb24gKi9cbiAgcHVibGljIGV4ZWN1dGlvbkR1cmF0aW9uOiBudW1iZXI7XG4gIC8qIFdoZXRoZXIgYW4gaW50ZXJydXB0IGxpc3RlbmVyIGlzIGF0dGFjaGVkIHRvIHRoZSBib2R5IG9yIG5vdCAqL1xuICBwdWJsaWMgaW50ZXJydXB0TGlzdGVuZXJzQXR0YWNoZWQgPSBmYWxzZTtcblxuICAvKiBSZWZlcmVuY2VzIHRvIHRoZSB0aW1lciBpbnN0YW5jZSB0aGF0IGlzIHVzZWQgdG8gcGVyZm9ybSB0aGUgc2Nyb2xsIGFuaW1hdGlvbiB0byBiZVxuICAgYWJsZSB0byBjbGVhciBpdCBvbiBhbmltYXRpb24gZW5kKi9cbiAgcHVibGljIHRpbWVyOiBhbnkgPSBudWxsO1xuXG4gIC8qKlxuICAgKiBQcml2YXRlIGNvbnN0cnVjdG9yLCByZXF1aXJlcyB0aGUgcHJvcGVydGllcyBhc3N1bWVkIHRvIGJlIHRoZSBiYXJlIG1pbmltdW0uXG4gICAqIFVzZSB0aGUgZmFjdG9yeSBtZXRob2RzIHRvIGNyZWF0ZSBpbnN0YW5jZXM6XG4gICAqICAgICAge0BsaW5rIFBhZ2VTY3JvbGxTZXJ2aWNlI2NyZWF0ZX1cbiAgICovXG4gIGNvbnN0cnVjdG9yKHBhZ2VTY3JvbGxPcHRpb25zOiBQYWdlU2Nyb2xsT3B0aW9ucykge1xuICAgIGlmICghcGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVmlld3MgfHwgcGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVmlld3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBwYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxWaWV3cyA9IFtcbiAgICAgICAgcGFnZVNjcm9sbE9wdGlvbnMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LFxuICAgICAgICBwYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5ib2R5LFxuICAgICAgICBwYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5ib2R5LnBhcmVudE5vZGUsXG4gICAgICBdO1xuICAgICAgdGhpcy5pc0lubGluZVNjcm9sbGluZyA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmlzSW5saW5lU2Nyb2xsaW5nID0gdHJ1ZTtcbiAgICB9XG5cbiAgICB0aGlzLnBhZ2VTY3JvbGxPcHRpb25zID0gcGFnZVNjcm9sbE9wdGlvbnM7XG4gIH1cblxuICBwcml2YXRlIHN0YXRpYyBnZXRTY3JvbGxpbmdUYXJnZXRQb3NpdGlvbihwYWdlU2Nyb2xsT3B0aW9uczogUGFnZVNjcm9sbE9wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNjcm9sbFRhcmdldEVsZW1lbnQ6IEhUTUxFbGVtZW50KTogeyB0b3A6IG51bWJlciwgbGVmdDogbnVtYmVyIH0ge1xuICAgIGNvbnN0IGJvZHkgPSBwYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGRvY0VsID0gcGFnZVNjcm9sbE9wdGlvbnMuZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXG4gICAgY29uc3Qgd2luZG93UGFnZVlPZmZzZXQ6IG51bWJlciA9IHBhZ2VTY3JvbGxPcHRpb25zLmRvY3VtZW50LmRlZmF1bHRWaWV3ICYmXG4gICAgICBwYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWU9mZnNldCB8fCB1bmRlZmluZWQ7XG4gICAgY29uc3Qgd2luZG93UGFnZVhPZmZzZXQ6IG51bWJlciA9IHBhZ2VTY3JvbGxPcHRpb25zLmRvY3VtZW50LmRlZmF1bHRWaWV3ICYmXG4gICAgICBwYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5kZWZhdWx0Vmlldy5wYWdlWE9mZnNldCB8fCB1bmRlZmluZWQ7XG5cbiAgICBjb25zdCBzY3JvbGxUb3AgPSB3aW5kb3dQYWdlWU9mZnNldCB8fCBkb2NFbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XG4gICAgY29uc3Qgc2Nyb2xsTGVmdCA9IHdpbmRvd1BhZ2VYT2Zmc2V0IHx8IGRvY0VsLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuXG4gICAgY29uc3QgY2xpZW50VG9wID0gZG9jRWwuY2xpZW50VG9wIHx8IGJvZHkuY2xpZW50VG9wIHx8IDA7XG4gICAgY29uc3QgY2xpZW50TGVmdCA9IGRvY0VsLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDA7XG5cbiAgICBpZiAoc2Nyb2xsVGFyZ2V0RWxlbWVudCA9PT0gdW5kZWZpbmVkIHx8IHNjcm9sbFRhcmdldEVsZW1lbnQgPT09IG51bGwpIHtcbiAgICAgIC8vIE5vIGVsZW1lbnQgZm91bmQsIHNvIHJldHVybiB0aGUgY3VycmVudCBwb3NpdGlvbiB0byBub3QgY2F1c2UgYW55IGNoYW5nZSBpbiBzY3JvbGwgcG9zaXRpb25cbiAgICAgIHJldHVybiB7dG9wOiBzY3JvbGxUb3AsIGxlZnQ6IHNjcm9sbExlZnR9O1xuICAgIH1cbiAgICBjb25zdCBib3ggPSBzY3JvbGxUYXJnZXRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXG4gICAgY29uc3QgdG9wID0gYm94LnRvcCArIHNjcm9sbFRvcCAtIGNsaWVudFRvcDtcbiAgICBjb25zdCBsZWZ0ID0gYm94LmxlZnQgKyBzY3JvbGxMZWZ0IC0gY2xpZW50TGVmdDtcblxuICAgIHJldHVybiB7dG9wOiBNYXRoLnJvdW5kKHRvcCksIGxlZnQ6IE1hdGgucm91bmQobGVmdCl9O1xuICB9XG5cbiAgcHJpdmF0ZSBzdGF0aWMgZ2V0SW5saW5lU2Nyb2xsaW5nVGFyZ2V0UG9zaXRpb24ocGFnZVNjcm9sbE9wdGlvbnM6IFBhZ2VTY3JvbGxPcHRpb25zLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzY3JvbGxUYXJnZXRFbGVtZW50OiBIVE1MRWxlbWVudCk6IHsgdG9wOiBudW1iZXIsIGxlZnQ6IG51bWJlciB9IHtcbiAgICBjb25zdCBwb3NpdGlvbiA9IHt0b3A6IHNjcm9sbFRhcmdldEVsZW1lbnQub2Zmc2V0VG9wLCBsZWZ0OiBzY3JvbGxUYXJnZXRFbGVtZW50Lm9mZnNldExlZnR9O1xuICAgIGlmIChwYWdlU2Nyb2xsT3B0aW9ucy5hZHZhbmNlZElubGluZU9mZnNldENhbGN1bGF0aW9uICYmIHBhZ2VTY3JvbGxPcHRpb25zLnNjcm9sbFZpZXdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgY29uc3QgYWNjdW11bGF0ZWRQYXJlbnRzUG9zID0ge3RvcDogMCwgbGVmdDogMH07XG4gICAgICAvLyBub3QgbmFtZWQgd2luZG93IHRvIG1ha2Ugc3VyZSB3ZSdyZSBub3QgZ2V0dGluZyB0aGUgZ2xvYmFsIHdpbmRvdyB2YXJpYWJsZSBieSBhY2NpZGVudFxuICAgICAgY29uc3QgdGhlV2luZG93ID0gc2Nyb2xsVGFyZ2V0RWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuICAgICAgbGV0IHBhcmVudEZvdW5kID0gZmFsc2U7XG5cbiAgICAgIC8vIFN0YXJ0IHBhcmVudCBpcyB0aGUgaW1tZWRpYXRlIHBhcmVudFxuICAgICAgbGV0IHBhcmVudCA9IHNjcm9sbFRhcmdldEVsZW1lbnQucGFyZW50RWxlbWVudDtcblxuICAgICAgLy8gSXRlcmF0ZSB1cHdhcmRzIGFsbCBwYXJlbnRzXG4gICAgICB3aGlsZSAoIXBhcmVudEZvdW5kICYmIHBhcmVudCAhPT0gdW5kZWZpbmVkICYmIHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgICBpZiAodGhlV2luZG93LmdldENvbXB1dGVkU3R5bGUocGFyZW50KS5nZXRQcm9wZXJ0eVZhbHVlKCdwb3NpdGlvbicpID09PSAncmVsYXRpdmUnKSB7XG4gICAgICAgICAgYWNjdW11bGF0ZWRQYXJlbnRzUG9zLnRvcCArPSBwYXJlbnQub2Zmc2V0VG9wO1xuICAgICAgICAgIGFjY3VtdWxhdGVkUGFyZW50c1Bvcy5sZWZ0ICs9IHBhcmVudC5vZmZzZXRMZWZ0O1xuICAgICAgICB9XG4gICAgICAgIC8vIE5leHQgaXRlcmF0aW9uXG4gICAgICAgIHBhcmVudCA9IHBhcmVudC5wYXJlbnRFbGVtZW50O1xuICAgICAgICBwYXJlbnRGb3VuZCA9IHBhcmVudCA9PT0gcGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVmlld3NbMF07XG4gICAgICB9XG4gICAgICBpZiAocGFyZW50Rm91bmQpIHtcbiAgICAgICAgLy8gT25seSB1c2UgdGhlIHJlc3VsdHMgaWYgd2UgZm91bmQgdGhlIHBhcmVudCwgb3RoZXJ3aXNlIHdlIGFjY3VtdWxhdGVkIHRvbyBtdWNoIGFueXdheVxuICAgICAgICBwb3NpdGlvbi50b3AgKz0gYWNjdW11bGF0ZWRQYXJlbnRzUG9zLnRvcDtcbiAgICAgICAgcG9zaXRpb24ubGVmdCArPSBhY2N1bXVsYXRlZFBhcmVudHNQb3MubGVmdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIFRPRE8gVW5jb21tZW50XG4gICAgICAgIGlmIChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAyIHx8IChQYWdlU2Nyb2xsQ29uZmlnLl9sb2dMZXZlbCA+PSAxICYmIGlzRGV2TW9kZSgpKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybignVW5hYmxlIHRvIGZpbmQgbmVzdGVkIHNjcm9sbGluZyB0YXJnZXRzIHBhcmVudCEnKTtcbiAgICAgICAgfSovXG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvc2l0aW9uO1xuICB9XG5cbiAgcHVibGljIGdldFNjcm9sbFByb3BlcnR5VmFsdWUoc2Nyb2xsaW5nVmlldzogYW55KTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMucGFnZVNjcm9sbE9wdGlvbnMudmVydGljYWxTY3JvbGxpbmcpIHtcbiAgICAgIHJldHVybiBzY3JvbGxpbmdWaWV3LnNjcm9sbExlZnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHNjcm9sbGluZ1ZpZXcuc2Nyb2xsVG9wO1xuICB9XG5cbiAgcHVibGljIGdldFNjcm9sbENsaWVudFByb3BlcnR5VmFsdWUoc2Nyb2xsaW5nVmlldzogYW55KTogbnVtYmVyIHtcbiAgICBpZiAoIXRoaXMucGFnZVNjcm9sbE9wdGlvbnMudmVydGljYWxTY3JvbGxpbmcpIHtcbiAgICAgIHJldHVybiBzY3JvbGxpbmdWaWV3LmNsaWVudFdpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiBzY3JvbGxpbmdWaWV3LmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeHRyYWN0IHRoZSBleGFjdCBsb2NhdGlvbiBvZiB0aGUgc2Nyb2xsVGFyZ2V0IGVsZW1lbnQuXG4gICAqXG4gICAqIEV4dHJhY3QgdGhlIHNjcm9sbFRhcmdldCBIVE1MRWxlbWVudCBmcm9tIHRoZSBnaXZlbiBQYWdlU2Nyb2xsVGFyZ2V0IG9iamVjdC4gVGhlIGxhdHRlciBvbmUgbWF5IGJlXG4gICAqIGEgc3RyaW5nIGxpa2UgXCIjaGVhZGluZzJcIiwgdGhlbiB0aGlzIG1ldGhvZCByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIERPTSBlbGVtZW50IGZvciB0aGF0IGlkLlxuICAgKlxuICAgKi9cbiAgcHVibGljIGV4dHJhY3RTY3JvbGxUYXJnZXRQb3NpdGlvbigpOiB7IHRvcDogbnVtYmVyLCBsZWZ0OiBudW1iZXIgfSB7XG4gICAgY29uc3Qgc2Nyb2xsVGFyZ2V0RWxlbWVudCA9IHRoaXMuZ2V0U2Nyb2xsVGFyZ2V0RWxlbWVudCgpO1xuXG4gICAgaWYgKHNjcm9sbFRhcmdldEVsZW1lbnQgPT09IG51bGwgfHwgc2Nyb2xsVGFyZ2V0RWxlbWVudCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBTY3JvbGwgdGFyZ2V0IG5vdCBmb3VuZFxuICAgICAgcmV0dXJuIHt0b3A6IE5hTiwgbGVmdDogTmFOfTtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pc0lubGluZVNjcm9sbGluZykge1xuICAgICAgcmV0dXJuIFBhZ2VTY3JvbGxJbnN0YW5jZS5nZXRJbmxpbmVTY3JvbGxpbmdUYXJnZXRQb3NpdGlvbih0aGlzLnBhZ2VTY3JvbGxPcHRpb25zLCBzY3JvbGxUYXJnZXRFbGVtZW50KTtcbiAgICB9XG5cbiAgICByZXR1cm4gUGFnZVNjcm9sbEluc3RhbmNlLmdldFNjcm9sbGluZ1RhcmdldFBvc2l0aW9uKHRoaXMucGFnZVNjcm9sbE9wdGlvbnMsIHNjcm9sbFRhcmdldEVsZW1lbnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldCB0aGUgdG9wIG9mZnNldCBvZiB0aGUgc2Nyb2xsIGFuaW1hdGlvbi5cbiAgICogVGhpcyBhdXRvbWF0aWNhbGx5IHRha2VzIHRoZSBvZmZzZXQgbG9jYXRpb24gb2YgdGhlIHNjcm9sbGluZyBjb250YWluZXIvc2Nyb2xsaW5nIHZpZXdcbiAgICogaW50byBhY2NvdW50IChmb3IgbmVzdGVkL2lubGluZSBzY3JvbGxpbmcpLlxuICAgKi9cbiAgcHVibGljIGdldEN1cnJlbnRPZmZzZXQoKTogbnVtYmVyIHtcbiAgICByZXR1cm4gdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxPZmZzZXQ7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgXCJzY3JvbGxUb3BcIiBvciBcInNjcm9sbExlZnRcIiBwcm9wZXJ0eSBmb3IgYWxsIHNjcm9sbFZpZXdzIHRvIHRoZSBwcm92aWRlZCB2YWx1ZVxuICAgKiBAcmV0dXJuIHRydWUgaWYgYXQgbGVhc3QgZm9yIG9uZSBTY3JvbGxUb3BTb3VyY2UgdGhlIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHZhbHVlIGNvdWxkIGJlIHNldCBhbmQgaXQga2VwdCB0aGUgbmV3IHZhbHVlLlxuICAgKiAgICAgICAgICBmYWxzZSBpZiBpdCBmYWlsZWQgZm9yIGFsbCBTY3JvbGxWaWV3cywgbWVhbmluZyB0aGF0IHdlIHNob3VsZCBzdG9wIHRoZSBhbmltYXRpb25cbiAgICogICAgICAgICAgKHByb2JhYmx5IGJlY2F1c2Ugd2UncmUgYXQgdGhlIGVuZCBvZiB0aGUgc2Nyb2xsaW5nIHJlZ2lvbilcbiAgICovXG4gIHB1YmxpYyBzZXRTY3JvbGxQb3NpdGlvbihwb3NpdGlvbjogbnVtYmVyKTogYm9vbGVhbiB7XG4gICAgLy8gU2V0IHRoZSBuZXcgc2Nyb2xsVG9wL3Njcm9sbExlZnQgdG8gYWxsIHNjcm9sbFZpZXdzIGVsZW1lbnRzXG4gICAgcmV0dXJuIHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVmlld3MucmVkdWNlKChvbmVBbHJlYWR5V29ya2VkOiBhbnksIHNjcm9sbGluZ1ZpZXc6IGFueSkgPT4ge1xuICAgICAgY29uc3Qgc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlID0gdGhpcy5nZXRTY3JvbGxQcm9wZXJ0eVZhbHVlKHNjcm9sbGluZ1ZpZXcpO1xuICAgICAgaWYgKHNjcm9sbGluZ1ZpZXcgJiYgc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlICE9PSB1bmRlZmluZWQgJiYgc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHNjcm9sbERpc3RhbmNlID0gTWF0aC5hYnMoc3RhcnRTY3JvbGxQcm9wZXJ0eVZhbHVlIC0gcG9zaXRpb24pO1xuXG4gICAgICAgIC8vIFRoZSBtb3ZlbWVudCB3ZSBuZWVkIHRvIHBlcmZvcm0gaXMgbGVzcyB0aGFuIDJweFxuICAgICAgICAvLyBUaGlzIHdlIGNvbnNpZGVyIGEgc21hbGwgbW92ZW1lbnQgd2hpY2ggc29tZSBicm93c2VyIG1heSBub3QgcGVyZm9ybSB3aGVuXG4gICAgICAgIC8vIGNoYW5naW5nIHRoZSBzY3JvbGxUb3Avc2Nyb2xsTGVmdCBwcm9wZXJ0eVxuICAgICAgICAvLyBUaHVzIGluIHRoaXMgY2FzZXMgd2UgZG8gbm90IHN0b3AgdGhlIHNjcm9sbCBhbmltYXRpb24sIGFsdGhvdWdoIHNldHRpbmcgdGhlXG4gICAgICAgIC8vIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHZhbHVlIFwiZmFpbHNcIlxuICAgICAgICBjb25zdCBpc1NtYWxsTW92ZW1lbnQgPSBzY3JvbGxEaXN0YW5jZSA8IHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuX21pblNjcm9sbERpc3RhbmNlO1xuXG4gICAgICAgIGlmICghdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy52ZXJ0aWNhbFNjcm9sbGluZykge1xuICAgICAgICAgIHNjcm9sbGluZ1ZpZXcuc2Nyb2xsTGVmdCA9IHBvc2l0aW9uO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNjcm9sbGluZ1ZpZXcuc2Nyb2xsVG9wID0gcG9zaXRpb247XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZXR1cm4gdHJ1ZSBpZiBzZXR0aW5nIHRoZSBuZXcgc2Nyb2xsVG9wL3Njcm9sbExlZnQgdmFsdWUgd29ya2VkXG4gICAgICAgIC8vIFdlIGNvbnNpZGVyIHRoYXQgaXQgd29ya2VkIGlmIHRoZSBuZXcgc2Nyb2xsVG9wL3Njcm9sbExlZnQgdmFsdWUgaXMgY2xvc2VyIHRvIHRoZVxuICAgICAgICAvLyBkZXNpcmVkIHNjcm9sbFRvcC9zY3JvbGxMZWZ0IHRoYW4gYmVmb3JlIChpdCBtaWdodCBub3QgYmUgZXhhY3RseSB0aGUgdmFsdWUgd2VcbiAgICAgICAgLy8gc2V0IGR1ZSB0byBkcGkgb3Igcm91bmRpbmcgaXJyZWd1bGFyaXRpZXMpXG4gICAgICAgIGlmIChpc1NtYWxsTW92ZW1lbnQgfHwgc2Nyb2xsRGlzdGFuY2UgPiBNYXRoLmFicyh0aGlzLmdldFNjcm9sbFByb3BlcnR5VmFsdWUoc2Nyb2xsaW5nVmlldykgLSBwb3NpdGlvbikpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb25lQWxyZWFkeVdvcmtlZDtcbiAgICB9LCBmYWxzZSk7XG4gIH1cblxuICAvKipcbiAgICogVHJpZ2dlciBmaXJpbmcgYSBhbmltYXRpb24gZmluaXNoIGV2ZW50XG4gICAqIEBwYXJhbSB2YWx1ZSBXaGV0aGVyIHRoZSBhbmltYXRpb24gZmluaXNoZWQgYXQgdGhlIHRhcmdldCAodHJ1ZSkgb3IgZ290IGludGVycnVwdGVkIChmYWxzZSlcbiAgICovXG4gIHB1YmxpYyBmaXJlRXZlbnQodmFsdWU6IGJvb2xlYW4pOiB2b2lkIHtcbiAgICBpZiAodGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxGaW5pc2hMaXN0ZW5lcikge1xuICAgICAgdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxGaW5pc2hMaXN0ZW5lci5lbWl0KHZhbHVlKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQXR0YWNoIHRoZSBpbnRlcnJ1cHQgbGlzdGVuZXJzIHRvIHRoZSBQYWdlU2Nyb2xsSW5zdGFuY2UgYm9keS4gVGhlIGdpdmVuIGludGVycnVwdFJlcG9ydGVyXG4gICAqIHdpbGwgYmUgY2FsbGVkIGlmIGFueSBvZiB0aGUgYXR0YWNoZWQgZXZlbnRzIGlzIGZpcmVkLlxuICAgKlxuICAgKiBQb3NzaWJseSBhdHRhY2hlZCBpbnRlcnJ1cHRMaXN0ZW5lcnMgYXJlIGF1dG9tYXRpY2FsbHkgcmVtb3ZlZCBmcm9tIHRoZSBib2R5IGJlZm9yZSB0aGUgbmV3IG9uZSB3aWxsIGJlIGF0dGFjaGVkLlxuICAgKi9cbiAgcHVibGljIGF0dGFjaEludGVycnVwdExpc3RlbmVycyhpbnRlcnJ1cHRSZXBvcnRlcjogSW50ZXJydXB0UmVwb3J0ZXIpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5pbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZCkge1xuICAgICAgLy8gRGV0YWNoIHBvc3NpYmx5IGV4aXN0aW5nIGxpc3RlbmVycyBmaXJzdFxuICAgICAgdGhpcy5kZXRhY2hJbnRlcnJ1cHRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gICAgdGhpcy5pbnRlcnJ1cHRMaXN0ZW5lciA9IChldmVudDogRXZlbnQpOiB2b2lkID0+IHtcbiAgICAgIGludGVycnVwdFJlcG9ydGVyLnJlcG9ydChldmVudCwgdGhpcyk7XG4gICAgfTtcbiAgICB0aGlzLnBhZ2VTY3JvbGxPcHRpb25zLmludGVycnVwdEV2ZW50cy5mb3JFYWNoKFxuICAgICAgKGV2ZW50OiBzdHJpbmcpID0+IHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCB0aGlzLmludGVycnVwdExpc3RlbmVyKVxuICAgICk7XG4gICAgdGhpcy5pbnRlcnJ1cHRMaXN0ZW5lcnNBdHRhY2hlZCA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogUmVtb3ZlIGV2ZW50IGxpc3RlbmVycyBmcm9tIHRoZSBib2R5IGFuZCBzdG9wIGxpc3RlbmluZyBmb3IgZXZlbnRzIHRoYXQgbWlnaHQgYmUgdHJlYXRlZCBhcyBcImFuaW1hdGlvblxuICAgKiBpbnRlcnJ1cHRcIiBldmVudHMuXG4gICAqL1xuICBwdWJsaWMgZGV0YWNoSW50ZXJydXB0TGlzdGVuZXJzKCk6IHZvaWQge1xuICAgIHRoaXMucGFnZVNjcm9sbE9wdGlvbnMuaW50ZXJydXB0RXZlbnRzLmZvckVhY2goXG4gICAgICAoZXZlbnQ6IHN0cmluZykgPT4gdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5ib2R5LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnQsIHRoaXMuaW50ZXJydXB0TGlzdGVuZXIpXG4gICAgKTtcbiAgICB0aGlzLmludGVycnVwdExpc3RlbmVyc0F0dGFjaGVkID0gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGdldFNjcm9sbFRhcmdldEVsZW1lbnQoKTogSFRNTEVsZW1lbnQge1xuICAgIGlmICh0eXBlb2YgdGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxUYXJnZXQgPT09ICdzdHJpbmcnKSB7XG4gICAgICBjb25zdCB0YXJnZXRTZWxlY3RvciA9IDxzdHJpbmc+dGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5zY3JvbGxUYXJnZXQ7XG4gICAgICBpZiAodGFyZ2V0U2VsZWN0b3IubWF0Y2goL14jW15cXHNdKyQvZykgIT09IG51bGwpIHtcbiAgICAgICAgLy8gSXQncyBhbiBpZCBzZWxlY3RvciBhbmQgYSB2YWxpZCBpZCwgYXMgaXQgZG9lcyBub3QgY29udGFpbiBhbnkgd2hpdGUgc3BhY2UgY2hhcmFjdGVyc1xuXG4gICAgICAgIHJldHVybiB0aGlzLnBhZ2VTY3JvbGxPcHRpb25zLmRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHRhcmdldFNlbGVjdG9yLnN1YnN0cigxKSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiA8SFRNTEVsZW1lbnQ+dGhpcy5wYWdlU2Nyb2xsT3B0aW9ucy5kb2N1bWVudC5xdWVyeVNlbGVjdG9yKHRhcmdldFNlbGVjdG9yKTtcbiAgICB9XG5cbiAgICByZXR1cm4gPEhUTUxFbGVtZW50PnRoaXMucGFnZVNjcm9sbE9wdGlvbnMuc2Nyb2xsVGFyZ2V0O1xuICB9XG59XG5cbi8qKlxuICogQW4gSW50ZXJmYWNlIGEgbGlzdGVuZXIgc2hvdWxkIGltcGxlbWVudCB0byBiZSBub3RpZmllZCBhYm91dCBwb3NzaWJsZSBpbnRlcnJ1cHQgZXZlbnRzXG4gKiB0aGF0IGhhcHBlbmVkIGR1ZSB0byB1c2VyIGludGVyYWN0aW9uIHdoaWxlIGEgc2Nyb2xsIGFuaW1hdGlvbiB0YWtlcyBwbGFjZS5cbiAqXG4gKiBUaGUgUGFnZVNjcm9sbFNlcnZpY2UgcHJvdmlkZXMgYW4gaW1wbGVtZW50YXRpb24gdG8gYSBQYWdlU2Nyb2xsSW5zdGFuY2UgdG8gYmUgbm90aWZpZWRcbiAqIGFib3V0IHNjcm9sbCBhbmltYXRpb24gaW50ZXJydXB0cyBhbmQgc3RvcCByZWxhdGVkIGFuaW1hdGlvbnMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgSW50ZXJydXB0UmVwb3J0ZXIge1xuICByZXBvcnQoZXZlbnQ6IEV2ZW50LCBwYWdlU2Nyb2xsSW5zdGFuY2U6IFBhZ2VTY3JvbGxJbnN0YW5jZSk6IHZvaWQ7XG59XG4iXX0=